---
title: "Template title"
abstract: "Template abstract"
lastUpdated: "October 23, 2023"
slug: async-await-in-lua
tags:
  - software eng
  - typescript
collection: null
isPublished: false
---

# Heading one

## Interlude: basic async-await with coroutines

Our `iterator_batcher` looks solid, but JavaScript developers will recognize the potential for
callback-hell: adding a nested `iterator_batcher` within an `on_complete` can lead to some very
indented and hard-to-read code. Instead, how can we "await" the batching in order to perform some
work which relies on the batching to complete, while also avoiding an `on_complete` callback?

The core of this solution uses three functions: `async`, `await`, and a `promise` - I work in web
development, so this is the pattern I'm most comfortable with.

Let's start with a classic timer example:

```lua
local function main()
  vim.print "start"
  vim.fn.timer_start(2000, function()
    vim.print "timer callback"
  end)
  vim.print "end"
end
main()

-- prints:
-- start
-- end
-- timer callback
```

How can we update the code so that the printed order becomes `start` -> `timer callback` -> `end`.
In JavaScript, we would create a promise that's resolved in the timer's callback:

```js
const promise = new Promise((resolve) => {
  setTimeout(() => {
    resolve();
  }, 2000);
});

async function main() {
  console.log("start");
  await promise;
  console.log("timer callback");
  console.log("end");
}
main();

// logs:
// start
// timer callback
// end
```

Let's try to follow the same pattern.

```lua
local function promise(resolve)
  vim.fn.timer_start(2000, resolve)
end

-- how can we create this syntax?
async local function main()
  vim.print "start"
  await promise -- and this?
  vim.print "timer callback"
  vim.print "end"
end
main()
```

What we want from `await` is to begin executing the promise, pause, resume when the async action in
the promise is complete, and continue on. Using coroutines, we can achieve this with just a few more
lines of code than with JavaScript.

```lua
local function promise(resolve)
  vim.fn.timer_start(2000, resolve)
end

--- @param promise fun(resolve: fun():nil):nil
local await = function(promise)
  local thread = coroutine.running()
  local resume_callback = function() coroutine.resume(thread) end
  promise(resume_callback)
  coroutine.yield()
end

local function main()
  vim.print "start"
  await(promise)
  vim.print "timer callback"
  vim.print "end"
end
coroutine.resume(coroutine.create(main))
vim.print "after resume"

-- prints:
-- start
-- after resume
-- timer callback
-- end
```

Let's walk through the execution of this code:

- A coroutine is created with the function `main` and immediately resumed
- `"start"` is printed
- `await` is called with `promise`
- `promise` is called, triggering the 2 second timer and scheduling `resume_callback` to be called
  at the end of the timer
- `coroutine.yield()` pauses the coroutine running `main`
- `"after resume"` is printed
- 2 seconds pass, triggering the callback passed to `timer_start` - which calls `resume_callback`
- `resume_callback` calls `coroutine.resume()`, which resumes the coroutine that's running `main`
- `"timer callback"` is printed
- `"end"` is printed

Notice that `await` assumes that it's called in the context of a coroutine (i.e. it uses
`coroutine.running`), which is why the code above wraps `main` in a `coroutine.resume` and
`coroutine.create`. However this code has a flaw: errors thrown in `main` are silently swallowed!
Try running this snippet:

```lua
local function main()
  error "Swallowed!"
end
coroutine.resume(coroutine.create(main))
```

This is where a dedicated `async` comes into play:

```lua
--- @param fn fun(...):nil
local async = function(fn)
  return function(...)
    local ok, err = coroutine.resume(coroutine.create(fn), ...)
    if not ok then error(err) end
  end
end
```

Updating `main`, that gives us:

```lua
local function promise(resolve)
  vim.fn.timer_start(2000, resolve)
end

local main = async(function()
  vim.print "start"
  await(promise)
  vim.print "timer callback"
  vim.print "end"
end)
main()
```

---

One downside of the current `await` function is that it assumes that `resume_callback` isn't called
immediately i.e. if it was called immediately, then the coroutine would _first_ resume _then_
yield - with nothing to resume the paused coroutine afterwards! A safer approach is to wrap
`promise` in `vim.schedule_wrap`, which you can think of as a `timer_start` with a timeout of `0`:

```lua
--- @param promise fun(resolve: fun():nil):nil
local await = function(promise)
  local thread = coroutine.running()
  assert(thread ~= nil, "`await` can only be called in a coroutine")
  local scheduled_promise = vim.schedule_wrap(promise)
  local resume_callback = function() coroutine.resume(thread) end
  scheduled_promise(resume_callback)
  coroutine.yield()
end
```

## Batching part 3: async-await

Back to our batcher function, we can use `async` and `await` to set the results buffer at the same
level of indentation as the `iterator_batcher`:

```lua
local populate_results = async(function(input)
  local results = {}
  local promise = function(resolve)
    iterator_batcher(
      function() return ipairs(large_tbl) end,
      function(entry)
        table.insert(results, ("%d :: %s"):format(entry, input))
      end,
      resolve
    )
  end
  await(promise)
  vim.api.nvim_buf_set_lines(results_bufnr, 0, -1, strict_indexing, results)
end)
```

Or a bit more reusable:

```lua
--- @generic InvariantState, ControlVar
--- @param iterator_factory fun(): ((fun(invariant_state: InvariantState, control_var: ControlVar):ControlVar), InvariantState, ControlVar)
--- @param on_iteration fun(entry: ControlVar):nil
--- @param batch_size_inclusive? number
local function async_iterator_batcher(iterator_factory, on_iteration, batch_size_inclusive)
  return function(resolve)
    iterator_batcher(iterator_factory, on_iteration, resolve, batch_size_inclusive)
  end
end

local populate_results = async(function(input)
  local results = {}
  local promise = async_iterator_batcher(
    function() return ipairs(large_tbl) end,
    function(entry)
      table.insert(results, ("%d :: %s"):format(entry, input))
    end
  )
  await(promise)
  vim.api.nvim_buf_set_lines(results_bufnr, 0, -1, strict_indexing, results)
end)
```
